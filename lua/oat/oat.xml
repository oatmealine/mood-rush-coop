<Mods LoadCommand="%xero(function(self)
	-- wenis times (setup)
	for i,aft in ipairs(oat_screenplayeraftsprite) do
		aft:SetTexture(oat_screenplayeraft:GetTexture())
		aft:diffusealpha(0)
		aft:croptop(0.01)
		aft:cropright(0.01)
		aft:cropleft(0.01)
		aft:cropbottom(0.01)

		aft:y(sh / 4)
		aft:rotationz(math.random(-20, 20))
		aft:x(math.random(sw/6, sw/6*5))
		aft:zoom(0.8)
	end

	oat_randomvert:hidden(1)
	oat_postsprite:SetTexture(fuck_aft:GetTexture())
	
	function modulo(a, b)
		return a - math.floor(a/b)*b;
	end

	local origPos = {}
	
	oat_partsaftspritebehind:SetTexture(oat_postaft:GetTexture())
	oat_partsaftspritebehind:diffuse(0.9, 0, 0, 1)

	for i,v in ipairs(oat_partsaftsprite) do
		v:xy(scx, scy)
		--v:zoomto(sw, sh)
	  v:SetTexture(oat_postaft:GetTexture())

		local ni = i-1
		local vni = math.floor(ni/24)

		local inv = 1/12
		local vinv = (1/12) * (4/3)

		local size = sw/12

		local roffset = math.floor(ni/12)%2

		v:cropleft( modulo(inv*ni, 1) )
		v:cropright( modulo((1 - inv) - inv*ni,1) )

		v:cropbottom(vinv*vni)
		v:croptop((1 - vinv) - vinv*vni)

		v:halign(modulo(inv*ni + inv/2, 1))
		v:valign( 1-modulo(vinv*vni + vinv/2, 1) )

		origPos[i] = {size/2 + modulo(ni,12)*size + roffset*sw, size/2 + vni*size}
		v:x( size/2 + modulo(ni,12)*size + roffset*sw )
		v:y( size/2 + vni*size )
	end
	
	local proxPos = {}
	local proxZoom = 0.8
	local proxDist = 64 * 4 * proxZoom -- 4 - column number
	for i,prox in ipairs(oat_proxyMarch) do
		local pn = ((i - 1) % 2) + 1

		local start = scx - proxDist * #oat_proxyMarch/2

		local x = start + proxDist * (i - 1)

		prox:SetTarget(P[pn]:GetChild('NoteField'))
		proxPos[i] = x
		prox:xy(scx, scy)

		prox:hidden(1)
		prox:diffusealpha(1/#oat_proxyMarch)
	end

	-- util funcs
	function table.contains(table, element)
		for _, value in pairs(table) do
			if value == element then
				return true
			end
		end
		return false
	end

	function math.round(a)
		if (a % 1) >= 0.5 then return math.ceil(a) end
		return math.floor(a)
	end

	local function reverseRotation(angleX, angleY, angleZ)
		local DEG_TO_RAD = math.pi / 180
		angleX, angleY, angleZ = DEG_TO_RAD * angleX, DEG_TO_RAD * angleY, DEG_TO_RAD * angleZ
		local sinX = math.sin(angleX);
		local cosX = math.cos(angleX);
		local sinY = math.sin(angleY);
		local cosY = math.cos(angleY);
		local sinZ = math.sin(angleZ);
		local cosZ = math.cos(angleZ);
		return 100 * math.atan2(-cosX*sinY*sinZ-sinX*cosZ,cosX*cosY), 100 * math.asin(-cosX*sinY*cosZ+sinX*sinZ), 100 * math.atan2(-sinX*sinY*cosZ-cosX*sinZ,cosY*cosZ)
	end

	local function confOff(deg)
		return math.rad(deg) * 100
	end

	local function mix(a, b, x)
		return a * (1 - x) + b * x
	end

	local randomVert = oat_randomvert:GetShader()

	local function enableVert(shader, players)
		players = players or {1, 2, 3, 4}

		for _,p in ipairs(players) do
			P[p]:SetArrowShader(shader)
			P[p]:SetHoldShader(shader)
		end
	end

	local function disableVert()
		enableVert('nothing') -- no other way ..... ha ha
	end

	local function enableRandVert(players)
		enableVert(randomVert, players)
	end

	local slump = GAMESTATE:GetCurrentSteps(0):GetDifficulty() == 5

	local function wrap(a)
		return function() end
	end

	-- eases
	local function onoff(x)
		return (x >= 1) and 0 or 1
	end

	local function reverse(x)
		return 1 - x
	end

	local function createReverse(func)
		return function(x)
			return 1 - func(x)
		end
	end

	local function createTemp(func)
		return function(x)
			if x > 0.999 then
				return 0
			end
			return func(x)
		end
	end

	local function bounc(a)
		if a < 0.5 then
			return outCirc(a * 2)
		else
			return 1 - inCirc(a * 2 - 1)
		end
	end

	-- custom modd de

	alias {'arrowfuck', function(a)
		randomVert:uniform1f('ampA', a)
	end}

	alias {'fuckarrow', function(a)
		randomVert:uniform1f('ampB', a)
	end}

	alias {'stealth2', function(a)
		randomVert:uniform1f('stealth', a)
	end}

	alias {'glitch2', function(a)
		oat_postsprite:GetShader():uniform1f('amount', a)
	end}

	-- The Real wenis times

	func {179, wrap(enableRandVert({1}))}

	ease {179, 1, outCirc, 90, 'stealth', -60, 'flip', 200, 'drunky', 400, 'tipsy', 700, 'drunk', 500, 'drunkz', 500, 'bumpyx', 100, 'dark', 100, 'boomerang', -100, 'zoom', 100, 'hidenoteflashes', plr = 2}
	ease {179, 1, outCirc, 50, 'tipsy', -10, 'flip', plr = 1}
	ease {180, 208-180, linear, 360 * 3, 'rotationy', confOff(-360 * 3), 'confusionyoffset', plr = 1}

	ease {204, 211-204, inOutSine, 100, 'reverse', -50, 'flip', 150, 'tipsy', plr = 1}

	func {211, 236-211, function(beat, poptions)
		local prog = (beat - 211) / (236 - 211)
		local anglex = mix(0, 360 * 3, prog)
		local angley = mix(360 * 3, 360 * 1, prog)

		local nx, ny, nz = reverseRotation(anglex, angley, 0)

		poptions[1].confusionxoffset = nx
		poptions[1].confusionyoffset = ny
	end}

	ease {211, 236-211, linear, 360 * 3, 'rotationx', 360 * 1, 'rotationy', plr = 1}
	ease {236, 4, outSine, 0, 'rotationx', 0, 'confusionxoffset'}

	ease {240, 3, inSine, 0, 'stealth', 0, 'flip', 0, 'drunky', 0, 'tipsy', 0, 'drunk', 0, 'drunkz', 0, 'bumpyx', 0, 'dark', 0, 'boomerang', 100, 'zoom', 0, 'hidenoteflashes', plr = 2}
	ease {240, 3, inSine, 0, 'rotationy', 0, 'confusionyoffset', 0, 'flip', 0, 'reverse', 0, 'tipsy', plr = 1}

	for i,b in ipairs(funihold) do
		local xory = ((i % 2) == 0) and 'x' or 'y'

		ease {b[1], 1 + (b[2] or 0) * 0.8, createReverse(outCirc), 0.5, 'glitch2', 0.4, 'arrowfuck', 0.4, 'fuckarrow', -170, 'tiny' .. xory, 160, 'tipsy'}
	end

	ease {244 - 2/3, 2/3 * 2, inOutCirc, 200, 'tipsy'}
	ease {244, 2/3 * 2, inOutCirc, -200, 'tipsy'}
	ease {245.5 - 0.5, 0.5 * 2, inOutCirc, 150, 'tipsy', 10, 'rotationz'}
	ease {246 - 0.5, 0.5 * 2, inOutCirc, -200, 'tipsy', -5, 'rotationz'}
	ease {246.5 - 0.5, 0.5 * 2, inOutCirc, 200, 'tipsy', 0, 'rotationz'}
	ease {247.5 - 0.5, 0.5 * 2, inOutCirc, -200, 'tipsy', 100, 'reverse'}
	ease {248 - 0.5, 0.5 * 2, inOutCirc, 150, 'tipsy', 0, 'reverse'}
	ease {247.5, 0.5, createReverse(outCirc), -50, 'tinyx'}
	ease {248, 0.5, createReverse(outCirc), -50, 'tinyy'}
	ease {248.5 - 2/3, 2/3 * 2, inOutCirc, -200, 'tipsy', -20, 'rotationz'}
	ease {249.167 - 2/3, 2/3 * 2, inOutCirc, 150, 'tipsy', 15, 'rotationz'}
	ease {249.833 - 0.5, 0.5 * 2, inOutCirc, -200, 'tipsy', -5, 'rotationz'}
	ease {250.75 - 0.5, 0.5 * 2, inOutCirc, 0, 'tipsy', 10, 'rotationz', 100, 'reverse'}
	ease {252 - 0.5, 0.5 * 2, inOutCirc, 0, 'rotationz', 0, 'reverse'}

	for i,b in ipairs(jump) do
		local aftNum = ((i - 1) % #oat_screenplayeraftsprite) + 1
		local aftNumRaw = i
		local playerNum = ((aftNum - 1) % #oat_screenplayeraft) + 1
		local aft = oat_screenplayeraftsprite[aftNum]
		
		ease {b[1], 1, outCirc, 1, function(a)
			aft:y(sh * 1.5 - a * sh)
			aft:diffusealpha(1)
		end}
		ease {b[1] + 1, 1, inCirc, 1, function(a)
			aft:y(sh/2 + a * sh)
		end}
	end

	ease {251, 1, inCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh/2 + sh * a)
		end
	end}
	ease {255, 1, outCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh * 1.5 - sh * a)
		end
	end}
	ease {260, 1, inCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh/2 + sh * a)
		end
	end}
	ease {259, 1, outCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:rotationz(a * 360)
		end
	end}
	ease {263, 1, outCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh * 1.5 - sh * a)
		end
	end}

	ease {256, 1, outCirc, 180, 'rotationy', confOff(-180), 'confusionyoffset'}
	set {257, 0, 'rotationy', 0, 'confusionyoffset', 100, 'flip'}
	ease {257, 1, outCirc, 180, 'rotationx', confOff(-180), 'confusionxoffset'}
	set {258, 0, 'rotationx', 0, 'confusionxoffset', 100, 'reverse'}
	ease {258, 1, outCirc, 180, 'rotationz', confOff(-180), 'confusionzoffset'}
	set {259, 0, 'rotationz', 0, 'confusionzoffset', 0, 'reverse', 0, 'flip'}

	ease {264, 0.4, outCirc, 100, 'reverse'}
	ease {264 + 2/3, 0.4, outCirc, 0, 'reverse'}
	ease {265, 0.4, outCirc, 100, 'invert'}
	ease {265 + 2/3, 0.4, outCirc, 0, 'invert'}
	ease {266, 0.4, outCirc, 100, 'reverse'}
	ease {266 + 2/3, 0.4, outCirc, 0, 'reverse'}

	ease {267, 1, bounce, -5000, 'tiny'}

	func {267.5, function()
		for i,aft in ipairs(oat_screenplayeraftsprite) do
			aft:hidden(1)
		end
	end}

	for i,b in ipairs(kick) do
		local off = (i % 2) * 2 - 1

		ease {b[1], 0.75, outCirc, 1, function(a)
			for i,prox in ipairs(oat_proxyMarch) do
				prox:x(proxPos[i] + a * proxDist * 2 * off)
			end
		end}
		ease {b[1], 1, createReverse(outCirc), 120, 'bumpy', 150, 'bumpyx', 0.7, 'glitch2', 1, function(a)
			local stren = 5
			local rotstren = 20

			oat_partsaftspritebehind:x(scx + a * math.random(-sw/50, sh/50) * stren * 0.7)
			oat_partsaftspritebehind:y(scy + a * math.random(-sh/40, sh/40) * stren * 0.7)

			for i,v in ipairs(oat_partsaftsprite) do
				v:x(origPos[i][1] + a * math.random(-sw/50, sw/20) * stren)
				v:y(origPos[i][2] + a * math.random(-sh/40, sh/40) * stren)

				--math.randomseed(aftNumRaw + i)
				v:rotationx(math.random(-rotstren, rotstren) * a)
				v:rotationy(math.random(-rotstren, rotstren) * a)
				v:rotationz(math.random(-rotstren, rotstren) * a)
			end
		end}
	end
	for _,b in ipairs(onlykicks) do
		ease {b[1], 1, createReverse(outCirc), 10, 'bumpyx', 1.2, 'glitch2', 1, function(a)
			local stren = 10
			local rotstren = 90
			
			oat_partsaftspritebehind:x(scx + a * math.random(-sw/50, sh/50) * stren * 0.7)
			oat_partsaftspritebehind:y(scy + a * math.random(-sh/40, sh/40) * stren * 0.7)

			for i,v in ipairs(oat_partsaftsprite) do
				v:x(origPos[i][1] + a * math.random(-sw/50, sw/50) * stren)
				v:y(origPos[i][2] + a * math.random(-sh/40, sh/40) * stren)

				--math.randomseed(aftNumRaw + i)
				v:rotationx(math.random(-rotstren, rotstren) * a)
				v:rotationy(math.random(-rotstren, rotstren) * a)
				v:rotationz(math.random(-rotstren, rotstren) * a)
			end
		end}
	end

	func {268, function()
		proxy.notefield[1]:hidden(1)
		proxy.notefield[2]:hidden(1)
		for _,prox in ipairs(oat_proxyMarch) do
			prox:hidden(0)
		end
	end}

	ease {274, 1, outCirc, 1, function(a)
		for _,prox in ipairs(oat_proxyMarch) do
			prox:zoom(mix(1, proxZoom, a))
			prox:diffusealpha(mix(1/#oat_proxyMarch, 1, a))
		end
	end}
	ease {275, 1, outCirc, -90, 'y', 200, 'drawsize', 360, 'rotationy', confOff(-360), 'confusionyoffset', 1, function(a)
		for i,prox in ipairs(oat_proxyMarch) do
			prox:x(mix(scx, proxPos[i], a))
		end
	end}

	ease {302, 2, inCirc, 1, function(a)
		for i,prox in ipairs(oat_proxyMarch) do
			math.randomseed(i * 12451)
			prox:y(sh/2 + a * sh)
			prox:rotationz(math.random(-70, 70) * a)
		end
	end}
	func {304, function()
		for i,prox in ipairs(oat_proxyMarch) do
			prox:hidden(1)
		end
	end}
	ease {302, 2, outCirc, 0, 'y', 0, 'drawsize', 1, function(a)
		proxy.notefield[1]:hidden(0)
		proxy.notefield[2]:hidden(0)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh * 1.5 - sh * a)
		end
	end}

	ease {303, 2/3 * 2, inOutCirc, -200, 'tipsy'}
	ease {304 - 2/3, 2/3 * 2, inOutCirc, 200, 'tipsy'}
	ease {304, 2/3 * 2, inOutCirc, -200, 'tipsy'}
	ease {305.5 - 0.5, 0.5 * 2, inOutCirc, 150, 'tipsy', 10, 'rotationz'}
	ease {306 - 0.5, 0.5 * 2, inOutCirc, -200, 'tipsy', -5, 'rotationz'}
	ease {306.5 - 0.5, 0.5 * 2, inOutCirc, 200, 'tipsy', 0, 'rotationz'}
	ease {307.5 - 0.5, 0.5 * 2, inOutCirc, 0, 'tipsy'}

	spellcard {176, 212, color = {.2, 0, .7, 1}, name = 'glitch2.frag and RotationY in The Adventure For Readability'}
	spellcard {212, 240, color = {.1, 0, .9, 1}, name = 'RotationY\'s unwanted twin brother'}
	spellcard {252, 276, color = {.6, 0, .4, 1}, name = 'Wake Up 2'}
	spellcard {276, 304, color = {.7, 0, 0, 1}, name = 'heard u liked finorza'}
	spellcard {304, 340, color = {.9, 0, 0, 1}, name = 'Dial-Up Streaming'}

	for b = 308, 332 - 1/3, 1/3 do
		ease {b, 1/3, outSine, 0.9, function(a)
			for _,v in ipairs(oat_partsaftsprite) do
				v:diffusealpha(1 - a)
			end
			oat_partsaftspritebehind:diffusealpha(1 - a)
		end}
	end
	for i,v in ipairs(invertkicks) do
		local b = v[1]

		func {b, function()
			oat_postaft:hidden(0)
		end}
		func {b + 0.1, function()
			oat_postaft:hidden(1)
		end}

		local mod = (i % 2 == 0) and 'invert' or 'none'
		ease {b, 1, onoff, 100, mod}
	end
	func {332 + 0.1, function()
		oat_postaft:hidden(0)
		for _,v in ipairs(oat_partsaftsprite) do
			v:diffusealpha(1)
		end
		oat_partsaftspritebehind:diffusealpha(1)
	end}

	set {332, 0, 'invert'}

	func {307, 332-307, function(beat, poptions)
		local rot = 60 * outCirc(math.min(beat - 307, 1))

		for pn = 1, 2 do
			local x = math.cos(beat) * rot
			local y = math.sin(beat) * rot
			poptions[pn].rotationx = x
			poptions[pn].rotationy = y

			local nx, ny, nz = reverseRotation(x, y, 0)

			poptions[pn].confusionxoffset = nx
			poptions[pn].confusionyoffset = ny
		end
	end}
end)"
	Type = "ActorFrame"
><children>
	<!-- sprites only made for shaders -->
	<Layer Type="Sprite" Texture="white" Vert="shaders/random.vert" Name="oat_randomvert"/>

	<!-- notedata -->
	<CODE File="funihold.xml"/>
	<CODE File="jump.xml"/>
	<CODE File="kick.xml"/>
	<CODE File="onlykicks.xml"/>
	<CODE File="invertkicks.xml"/>
</children></Mods>
