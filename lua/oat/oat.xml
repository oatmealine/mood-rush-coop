<Mods LoadCommand="%xero(function(self)
	-- wenis times (setup)
	for i,aft in ipairs(oat_screenplayeraftsprite) do
		aft:SetTexture(oat_screenplayeraft:GetTexture())
		aft:diffusealpha(0)
		aft:croptop(0.01)
		aft:cropright(0.01)
		aft:cropleft(0.01)
		aft:cropbottom(0.01)

		aft:y(sh / 4)
		aft:rotationz(math.random(-20, 20))
		aft:x(math.random(sw/6, sw/6*5))
		aft:zoom(0.8)
	end

	oat_randomvert:hidden(1)
	oat_postsprite:SetTexture(oat_postaft:GetTexture())
	
	-- util funcs
	function table.contains(table, element)
		for _, value in pairs(table) do
			if value == element then
				return true
			end
		end
		return false
	end

	local function reverseRotation(angleX, angleY, angleZ)
		local DEG_TO_RAD = math.pi / 180
		angleX, angleY, angleZ = DEG_TO_RAD * angleX, DEG_TO_RAD * angleY, DEG_TO_RAD * angleZ
		local sinX = math.sin(angleX);
		local cosX = math.cos(angleX);
		local sinY = math.sin(angleY);
		local cosY = math.cos(angleY);
		local sinZ = math.sin(angleZ);
		local cosZ = math.cos(angleZ);
		return 100 * math.atan2(-cosX*sinY*sinZ-sinX*cosZ,cosX*cosY), 100 * math.asin(-cosX*sinY*cosZ+sinX*sinZ), 100 * math.atan2(-sinX*sinY*cosZ-cosX*sinZ,cosY*cosZ)
	end

	local function confOff(deg)
		return math.rad(deg) * 100
	end

	local function mix(a, b, x)
		return a * (1 - x) + b * x
	end

	local randomVert = oat_randomvert:GetShader()

	local function enableVert(shader, players)
		players = players or {1, 2, 3, 4}

		for _,p in ipairs(players) do
			P[p]:SetArrowShader(shader)
			P[p]:SetHoldShader(shader)
		end
	end

	local function disableVert()
		enableVert('nothing') -- no other way ..... ha ha
	end

	local function enableRandVert(players)
		enableVert(randomVert, players)
	end

	local slump = GAMESTATE:GetCurrentSteps(0):GetDifficulty() == 5

	local function wrap(a)
		return function() end
	end

	-- eases
	local function onoff(x)
		return (x >= 1) and 0 or 1
	end

	local function reverse(x)
		return 1 - x
	end

	local function createReverse(func)
		return function(x)
			return 1 - func(x)
		end
	end

	local function createTemp(func)
		return function(x)
			if x > 0.999 then
				return 0
			end
			return func(x)
		end
	end

	local function bounc(a)
		if a < 0.5 then
			return outCirc(a * 2)
		else
			return 1 - inCirc(a * 2 - 1)
		end
	end

	-- custom modd de

	alias {'arrowfuck', function(a)
		randomVert:uniform1f('ampA', a)
	end}

	alias {'fuckarrow', function(a)
		randomVert:uniform1f('ampB', a)
	end}

	alias {'stealth2', function(a)
		randomVert:uniform1f('stealth', a)
	end}

	alias {'glitch2', function(a)
		oat_postsprite:GetShader():uniform1f('amount', a)
	end}

	-- The Real wenis times

	func {179, wrap(enableRandVert({1}))}

	ease {179, 1, outCirc, 90, 'stealth', -60, 'flip', 200, 'drunky', 400, 'tipsy', 700, 'drunk', 500, 'drunkz', 500, 'bumpyx', 100, 'dark', 100, 'boomerang', -100, 'zoom', 100, 'hidenoteflashes', plr = 2}
	ease {179, 1, outCirc, 50, 'tipsy', -10, 'flip', plr = 1}
	ease {180, 208-180, linear, 360 * 3, 'rotationy', confOff(-360 * 3), 'confusionyoffset', plr = 1}

	ease {204, 211-204, inOutSine, 100, 'reverse', -50, 'flip', 150, 'tipsy', plr = 1}

	func {211, 236-211, function(beat, poptions)
		local prog = (beat - 211) / (236 - 211)
		local anglex = mix(0, 360 * 3, prog)
		local angley = mix(360 * 3, 360 * 1, prog)

		local nx, ny, nz = reverseRotation(anglex, angley, 0)

		poptions[1].confusionxoffset = nx
		poptions[1].confusionyoffset = ny
	end}

	ease {211, 236-211, linear, 360 * 3, 'rotationx', 360 * 1, 'rotationy', plr = 1}
	ease {236, 4, outSine, 0, 'rotationx', 0, 'confusionxoffset'}

	ease {240, 3, inSine, 0, 'stealth', 0, 'flip', 0, 'drunky', 0, 'tipsy', 0, 'drunk', 0, 'drunkz', 0, 'bumpyx', 0, 'dark', 0, 'boomerang', 100, 'zoom', 0, 'hidenoteflashes', plr = 2}
	ease {240, 3, inSine, 0, 'rotationy', 0, 'confusionyoffset', 0, 'flip', 0, 'reverse', 0, 'tipsy', plr = 1}

	for i,b in ipairs(funihold) do
		local xory = ((i % 2) == 0) and 'x' or 'y'

		ease {b[1], 1 + (b[2] or 0) * 0.8, createReverse(outCirc), 0.5, 'glitch2', 0.4, 'arrowfuck', 0.4, 'fuckarrow', -170, 'tiny' .. xory, 160, 'tipsy'}
	end

	ease {244 - 2/3, 2/3 * 2, inOutCirc, 200, 'tipsy'}
	ease {244, 2/3 * 2, inOutCirc, -200, 'tipsy'}
	ease {245.5 - 0.5, 0.5 * 2, inOutCirc, 150, 'tipsy', 10, 'rotationz'}
	ease {246 - 0.5, 0.5 * 2, inOutCirc, -200, 'tipsy', -5, 'rotationz'}
	ease {246.5 - 0.5, 0.5 * 2, inOutCirc, 200, 'tipsy', 0, 'rotationz'}
	ease {247.5 - 0.5, 0.5 * 2, inOutCirc, -200, 'tipsy', 100, 'reverse'}
	ease {248 - 0.5, 0.5 * 2, inOutCirc, 150, 'tipsy', 0, 'reverse'}
	ease {247.5, 0.5, createReverse(outCirc), -50, 'tinyx'}
	ease {248, 0.5, createReverse(outCirc), -50, 'tinyy'}
	ease {248.5 - 2/3, 2/3 * 2, inOutCirc, -200, 'tipsy', -20, 'rotationz'}
	ease {249.167 - 2/3, 2/3 * 2, inOutCirc, 150, 'tipsy', 15, 'rotationz'}
	ease {249.833 - 0.5, 0.5 * 2, inOutCirc, -200, 'tipsy', -5, 'rotationz'}
	ease {250.75 - 0.5, 0.5 * 2, inOutCirc, 0, 'tipsy', 10, 'rotationz', 100, 'reverse'}
	ease {252 - 0.5, 0.5 * 2, inOutCirc, 0, 'rotationz', 0, 'reverse'}

	for i,b in ipairs(jump) do
		local aftNum = ((i - 1) % #oat_screenplayeraftsprite) + 1
		local aftNumRaw = i
		local playerNum = ((aftNum - 1) % #oat_screenplayeraft) + 1
		local aft = oat_screenplayeraftsprite[aftNum]
		
		ease {b[1], 1, outCirc, 1, function(a)
			aft:y(sh * 1.5 - a * sh)
			aft:diffusealpha(1)
		end}
		ease {b[1] + 1, 1, inCirc, 1, function(a)
			aft:y(sh/2 + a * sh)
		end}
	end

	ease {251, 1, inCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh/2 + sh * a)
		end
	end}
	ease {255, 1, outCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh * 1.5 - sh * a)
		end
	end}
	ease {259, 1, inCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh/2 + sh * a)
		end
	end}
	ease {259, 1, outCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:rotationz(a * 360)
		end
	end}
	ease {263, 1, outCirc, 1, function(a)
		for pn = 1, 2 do
			proxy.notefield[pn]:y(sh * 1.5 - sh * a)
		end
	end}

	ease {256, 1, outCirc, 180, 'rotationy', confOff(-180), 'confusionyoffset'}
	set {257, 0, 'rotationy', 0, 'confusionyoffset', 100, 'flip'}
	ease {257, 1, outCirc, 180, 'rotationx', confOff(-180), 'confusionxoffset'}
	set {258, 0, 'rotationx', 0, 'confusionxoffset', 100, 'reverse'}
	ease {258, 1, outCirc, 180, 'rotationz', confOff(-180), 'confusionzoffset'}
	set {259, 0, 'rotationz', 0, 'confusionzoffset', 0, 'reverse', 0, 'flip'}

	ease {264, 0.4, outCirc, 100, 'reverse'}
	ease {264 + 2/3, 0.4, outCirc, 0, 'reverse'}
	ease {265, 0.4, outCirc, 100, 'invert'}
	ease {265 + 2/3, 0.4, outCirc, 0, 'invert'}
	ease {266, 0.4, outCirc, 100, 'reverse'}
	ease {266 + 2/3, 0.4, outCirc, 0, 'reverse'}

	ease {267, 1, bounce, -5000, 'tiny'}

	func {267.5, function()
		for i,aft in ipairs(oat_screenplayeraftsprite) do
			aft:hidden(1)
		end
	end}
end)"
	Type = "ActorFrame"
><children>
	<!-- sprites only made for shaders -->
	<Layer Type="Sprite" Texture="white" Vert="shaders/random.vert" Name="oat_randomvert"/>

	<!-- notedata -->
	<CODE File="funihold.xml"/>
	<CODE File="jump.xml"/>
</children></Mods>
